#!/usr/bin/env node
/**
 * Canvas Roots CSS Build System
 *
 * A Node.js build script that:
 * - Lints CSS with Stylelint
 * - Formats CSS with Prettier
 * - Concatenates component files
 * - Generates final styles.css for Obsidian
 * - Provides watch mode for development
 *
 * @version 1.0.0
 */

const fs = require('fs').promises;
const path = require('path');
const chokidar = require('chokidar');
const chalk = require('chalk');
const { execSync } = require('child_process');

// Configuration
const CONFIG = {
  stylesDir: 'styles',
  outputFile: 'styles.css',
  tempFile: 'styles.tmp.css',

  // Component order for concatenation (dependency-aware)
  componentOrder: [
    'variables.css',      // CSS custom properties and design tokens
    'style-settings.css', // Style Settings plugin configuration
    'base.css',          // Base structural elements
    'layout.css',        // Layout utilities
    'canvas.css',        // Canvas-specific styling
    'nodes.css',         // Family tree node styling
    'edges.css',         // Relationship edge styling
    'settings.css',      // Settings interface
    'modals.css',        // Modal dialogs
    'duplicate-detection.css', // Duplicate detection modal
    'tree-statistics.css', // Tree statistics modal
    'validation.css',    // Validation results modal
    'find-on-canvas.css', // Find on canvas modal
    'folder-scan.css',   // Folder scan modal
    'relationship-calculator.css', // Relationship calculator modal
    'family-chart-view.css', // Interactive family chart view
    'data-quality.css',  // Data quality analysis tab
    'relationships.css', // Custom relationships tab
    'canvas-navigation.css', // Canvas navigation and split wizard
    'map-view.css',      // Leaflet map view (includes bundled Leaflet CSS)
    'leaflet-distortable.css', // Leaflet toolbar/distortable image plugins (vendored)
    'date-systems.css',  // Date systems card
    'events.css',        // Events and timeline components
    'timeline-callouts.css', // Timeline callout styles for markdown export
    'organizations.css', // Organizations tab
    'sources.css',       // Sources tab
    'preferences.css',   // Preferences tab
    'dynamic-content.css', // Dynamic content blocks (timeline, relationships)
    'animations.css',    // Keyframes and transitions
    'responsive.css',    // Responsive breakpoints
    'theme.css'          // Theme compatibility (last)
  ],

  // Files to exclude from processing
  excludedFiles: []
};

// Logging utilities with colors
const log = {
  info: (msg) => console.log(chalk.blue(`[INFO]`), msg),
  success: (msg) => console.log(chalk.green(`[SUCCESS]`), msg),
  warn: (msg) => console.log(chalk.yellow(`[WARN]`), msg),
  error: (msg) => console.log(chalk.red(`[ERROR]`), msg),
  debug: (msg) => console.log(chalk.gray(`[DEBUG]`), msg)
};

/**
 * Get file information (lines, size, etc.)
 */
async function getFileInfo(filePath) {
  try {
    const stats = await fs.stat(filePath);
    const content = await fs.readFile(filePath, 'utf8');
    const lines = content.split('\n').length;
    const sizeKB = (stats.size / 1024).toFixed(2);

    return {
      exists: true,
      lines,
      bytes: stats.size,
      sizeKB: parseFloat(sizeKB)
    };
  } catch (error) {
    return { exists: false };
  }
}

/**
 * Run Stylelint on component files
 */
async function lintCSS() {
  log.info('Running Stylelint on component files...');

  try {
    execSync('npx stylelint "styles/**/*.css"', {
      stdio: 'inherit',
      cwd: process.cwd()
    });
    log.success('CSS linting passed');
    return true;
  } catch (error) {
    log.error('CSS linting failed');
    return false;
  }
}

/**
 * Format CSS files with Prettier
 */
async function formatCSS() {
  log.info('Formatting CSS with Prettier...');

  try {
    execSync('npx prettier --write "styles/**/*.css"', {
      stdio: 'inherit',
      cwd: process.cwd()
    });
    log.success('CSS formatting completed');
    return true;
  } catch (error) {
    log.error('CSS formatting failed');
    return false;
  }
}

/**
 * Generate build header with metadata
 */
function generateBuildHeader(componentCount) {
  const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19) + ' UTC';

  return `/* ==========================================================================
   Canvas Roots Plugin Stylesheet - BUILT VERSION
   ========================================================================== */

/* Canvas Roots: Family Trees in Obsidian Canvas
 * An Obsidian plugin for creating and visualizing family trees using D3.js layouts.
 *
 * GitHub: https://github.com/banisterious/obsidian-canvas-roots
 *
 * BUILD INFORMATION:
 * - Generated: ${timestamp}
 * - Components: ${componentCount} files
 * - Build System: Node.js CSS Build Script v1.0.0
 *
 * NOTE: This file is automatically generated from component files in styles/
 * Do not edit this file directly - edit the component files instead!
 * Run 'npm run build:css' to regenerate this file.
 */

`;
}

/**
 * Generate component header
 */
function generateComponentHeader(componentName, fileInfo) {
  return `
/* ==========================================================================
   COMPONENT: ${componentName.toUpperCase()}
   ========================================================================== */

/* Component Size: ${fileInfo.lines} lines, ${fileInfo.sizeKB} KB */

`;
}

/**
 * Generate build footer with statistics
 */
function generateBuildFooter(stats, componentBreakdown) {
  const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19) + ' UTC';

  let footer = `
/* ==========================================================================
   BUILD STATISTICS
   ========================================================================== */

/*
 * Build completed: ${timestamp}
 * Components processed: ${stats.componentCount}
 * Total lines: ${stats.totalLines}
 * Total size: ${stats.totalKB} KB
 * Build duration: ${stats.buildDuration} seconds
 *
 * Component breakdown:`;

  componentBreakdown.forEach(component => {
    footer += `\n * - ${component.name}: ${component.lines} lines, ${component.sizeKB} KB`;
  });

  footer += `\n */\n\n/* End of generated stylesheet */\n`;

  return footer;
}

/**
 * Main CSS build function
 */
async function buildCSS() {
  const buildStart = Date.now();
  log.info('Starting CSS build process...');

  try {
    // Check if styles directory exists
    const stylesPath = path.join(process.cwd(), CONFIG.stylesDir);
    await fs.access(stylesPath);
  } catch (error) {
    log.error(`Styles directory '${CONFIG.stylesDir}' not found!`);
    return false;
  }

  // Initialize build metrics
  let totalLines = 0;
  let totalBytes = 0;
  let componentCount = 0;
  const componentBreakdown = [];

  // Start building
  let buildContent = generateBuildHeader(CONFIG.componentOrder.length);

  log.info(`Processing ${CONFIG.componentOrder.length} CSS components...`);

  // Process each component in order
  for (const component of CONFIG.componentOrder) {
    const componentPath = path.join(CONFIG.stylesDir, component);
    const fileInfo = await getFileInfo(componentPath);

    if (fileInfo.exists) {
      log.info(`  + ${component} (${fileInfo.lines} lines, ${fileInfo.sizeKB} KB)`);

      // Add component header
      buildContent += generateComponentHeader(component, fileInfo);

      // Add component content
      const componentContent = await fs.readFile(componentPath, 'utf8');
      buildContent += componentContent;

      // Add component footer
      buildContent += `\n\n/* End of ${component} */\n`;

      // Update metrics
      totalLines += fileInfo.lines;
      totalBytes += fileInfo.bytes;
      componentCount++;

      componentBreakdown.push({
        name: component,
        lines: fileInfo.lines,
        sizeKB: fileInfo.sizeKB
      });
    } else {
      log.warn(`  - ${component} (not found, skipping)`);
    }
  }

  // Check for orphaned files
  const allFiles = await fs.readdir(CONFIG.stylesDir);
  const cssFiles = allFiles.filter(file =>
    file.endsWith('.css') &&
    !CONFIG.excludedFiles.includes(file) &&
    !CONFIG.componentOrder.includes(file)
  );

  if (cssFiles.length > 0) {
    log.warn(`Found ${cssFiles.length} orphaned CSS files:`);
    cssFiles.forEach(file => {
      log.warn(`  ! ${file} (not in build order)`);
    });
  }

  // Calculate final statistics
  const buildEnd = Date.now();
  const buildDuration = ((buildEnd - buildStart) / 1000).toFixed(2);
  const totalKB = (totalBytes / 1024).toFixed(2);

  const stats = {
    componentCount,
    totalLines,
    totalKB: parseFloat(totalKB),
    buildDuration: parseFloat(buildDuration)
  };

  // Add build footer
  buildContent += generateBuildFooter(stats, componentBreakdown);

  // Write to temporary file first
  await fs.writeFile(CONFIG.tempFile, buildContent, 'utf8');

  // Check if output file exists
  const outputExists = await getFileInfo(CONFIG.outputFile);
  if (outputExists.exists) {
    log.info(`Replacing existing ${CONFIG.outputFile} (${outputExists.sizeKB} KB)`);
  }

  // Move temp file to final output
  await fs.rename(CONFIG.tempFile, CONFIG.outputFile);

  // Final verification
  const finalInfo = await getFileInfo(CONFIG.outputFile);

  log.success('Build completed successfully!');
  log.success(`Generated: ${CONFIG.outputFile} (${finalInfo.lines} lines, ${finalInfo.sizeKB} KB)`);
  log.success(`Build time: ${buildDuration} seconds`);

  return true;
}

/**
 * Watch mode for development
 */
async function watchCSS() {
  log.info('Starting CSS watch mode...');
  log.info(`Watching for changes in ${CONFIG.stylesDir} directory...`);
  log.info('Press Ctrl+C to stop watching');

  // Initial build
  await buildCSS();

  // Setup file watcher
  const watcher = chokidar.watch(path.join(CONFIG.stylesDir, '*.css'), {
    ignored: /(^|[\/\\])\../, // ignore dotfiles
    persistent: true,
    ignoreInitial: true
  });

  watcher.on('change', async (filePath) => {
    const fileName = path.basename(filePath);
    log.info(`Detected change in ${fileName}, rebuilding...`);
    await buildCSS();
  });

  watcher.on('add', async (filePath) => {
    const fileName = path.basename(filePath);
    log.info(`New file added: ${fileName}, rebuilding...`);
    await buildCSS();
  });

  watcher.on('unlink', async (filePath) => {
    const fileName = path.basename(filePath);
    log.info(`File removed: ${fileName}, rebuilding...`);
    await buildCSS();
  });

  // Handle graceful shutdown
  process.on('SIGINT', () => {
    log.info('Stopping watch mode...');
    watcher.close();
    process.exit(0);
  });
}

/**
 * Full build pipeline with linting and formatting
 */
async function fullBuild() {
  log.info('Starting full CSS build pipeline...');

  // Step 1: Format CSS files
  const formatSuccess = await formatCSS();
  if (!formatSuccess) {
    log.error('Build failed at formatting stage');
    process.exit(1);
  }

  // Step 2: Lint CSS files
  const lintSuccess = await lintCSS();
  if (!lintSuccess) {
    if (process.argv.includes('--no-fail-on-lint')) {
      log.warn('CSS linting failed but continuing build due to --no-fail-on-lint flag...');
    } else {
      log.error('Build failed at linting stage');
      process.exit(1);
    }
  }

  // Step 3: Build CSS
  const buildSuccess = await buildCSS();
  if (!buildSuccess) {
    log.error('Build failed at build stage');
    process.exit(1);
  }

  log.success('Full CSS build pipeline completed successfully!');
}

/**
 * Main execution
 */
async function main() {
  const args = process.argv.slice(2);
  const isWatch = args.includes('--watch') || args.includes('-w');
  const isLintOnly = args.includes('--lint') || args.includes('-l');
  const isFormatOnly = args.includes('--format') || args.includes('-f');
  const isBuildOnly = args.includes('--build-only') || args.includes('-b');

  console.log(chalk.cyan('\nðŸŽ¨ Canvas Roots CSS Build System v1.0.0\n'));

  try {
    if (isLintOnly) {
      await lintCSS();
    } else if (isFormatOnly) {
      await formatCSS();
    } else if (isBuildOnly) {
      await buildCSS();
    } else if (isWatch) {
      await watchCSS();
    } else {
      await fullBuild();
    }
  } catch (error) {
    log.error(`Build failed: ${error.message}`);
    process.exit(1);
  }
}

// Run the build system
if (require.main === module) {
  main();
}

module.exports = {
  buildCSS,
  lintCSS,
  formatCSS,
  watchCSS
};
